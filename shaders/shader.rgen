#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_debug_printf : enable

#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "../include/common_types.h"
#include "../include/common_shader_functions.glsl"

#define M_PI 3.1415926535897932384626433832795

layout(location = 0) rayPayloadEXT Payload
{
	vec3 rayOrigin;
	vec3 rayDirection;
	vec3 previousNormal;

	vec3 directColor;
	vec3 indirectColor;
	int rayDepth;

	int rayActive;

	int hitBezierTriangleCounter;
}
payload;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0) uniform UniformStructure
{
	mat4 viewProj;
	mat4 viewInverse;
	mat4 projInverse;

	vec4 position;
	vec4 right;
	vec4 up;
	vec4 forward;

	uint frameCount;
}
ubo;

layout(binding = 4, set = 0, rgba32f) uniform image2D image;

layout(set = 0, binding = 8, scalar) buffer SlicingPlanes
{
	SlicingPlane[] slicingPlanes;
};

layout(push_constant) uniform RaytracingDataConstants{
    // see common_types.h
    PUSH_CONSTANT_MEMBERS} raytracingDataConstants;

// float random(vec2 uv, float seed)
// {
// 	return fract(sin(mod(dot(uv, vec2(12.9898, 78.233)) + 1113.1 * seed, M_PI)) * 43758.5453);
// 	;
// }

void main()
{
	vec2 uv = gl_LaunchIDEXT.xy
	          + vec2(0.5); // + vec2(random(gl_LaunchIDEXT.xy, 0), random(gl_LaunchIDEXT.xy, 1));
	uv /= vec2(gl_LaunchSizeEXT.xy);
	uv = uv * 2.0f - 1.0f;

	vec4 origin = ubo.viewInverse * vec4(0, 0, 0, 1);
	vec4 target = ubo.projInverse * vec4(uv.x, uv.y, 1, 1);
	vec4 direction = ubo.viewInverse * vec4(normalize(target.xyz), 0);

	payload.rayOrigin = origin.xyz;
	payload.rayDirection = direction.xyz;
	payload.previousNormal = vec3(0.0, 0.0, 0.0);

	payload.directColor = raytracingDataConstants.environmentColor;
	payload.indirectColor = vec3(0.0, 0.0, 0.0);
	payload.rayDepth = 0;

	payload.rayActive = 1;

	payload.hitBezierTriangleCounter = 0;

	bool isCrosshairRay = false;
	// whether or not the current ray direction is the crosshair's direction
	vec3 cameraDir = raytracingDataConstants.cameraDir;
	if (abs(dot(normalize(direction.xyz), normalize(cameraDir)) - 1) < 0.0000001)
	{
		isCrosshairRay = true;
	}

	isCrosshairRay = raytracingDataConstants.debugPrintCrosshairRay > 0.0 && isCrosshairRay;

	for (int x = 0; x < raytracingDataConstants.recursiveRaysPerPixel; x++)
	{
		traceRayEXT(topLevelAS,
		            gl_RayFlagsOpaqueEXT,
		            0xFF,
		            0,
		            0,
		            0,
		            payload.rayOrigin,
		            0.01,
		            payload.rayDirection,
		            1000.0,
		            0);

		if (raytracingDataConstants.enableSlicingPlanes > 0.0
		    && payload.hitBezierTriangleCounter > 0)
		{
			// count how many times we hit the bezier triangle again
			// the hits only count when they are in front of the slicing plane
			// if the count is odd, the hitpos on the slicing plane is inside the object
			// if the count is even, the intersection pos with the ray and slicing plane is outside
			// the object

			// TODO: figure out what the maximum number of hits is for a given tetrahedron degree
			// is it 2 * n ??
			for (int c = 0; c < 4; c++)
			{
				int oldCounter = payload.hitBezierTriangleCounter;
				vec3 oldOrigin = payload.rayOrigin;
				payload.rayOrigin
				    += payload.rayDirection * raytracingDataConstants.someFloatingScalar;

				traceRayEXT(topLevelAS,
				            gl_RayFlagsOpaqueEXT,
				            0xFF,
				            0,
				            0,
				            1,
				            payload.rayOrigin,
				            0.001,
				            payload.rayDirection,
				            1000.0,
				            0);

				// if no additional hit was found, break
				// if (payload.hitBezierTriangleCounter == oldCounter)
				// {
				// 	break;
				// }
			}

			int idx = 0;
			float t = 0.0;
			SlicingPlane plane = slicingPlanes[idx];

			bool hitPlane = intersectWithPlane(
			    plane.normal, plane.planeOrigin, payload.rayOrigin, payload.rayDirection, t);

			if (isCrosshairRay)
			{
				debugPrintfEXT("Hitting bezier triangle %d times - Hit Plane: %d",
				               payload.hitBezierTriangleCounter,
				               hitPlane);
			}

			if (hitPlane && (payload.hitBezierTriangleCounter % 2 == 1))
			{
				// hit odd number of bezier triangles before hitting normal plane
				// this means we are inside the object - render triangele inside color
				payload.directColor = vec3(0.0, 0.0, 1.0);
				payload.indirectColor = vec3(0.0, 0.0, 0.0);
			}
			else
			{
				// hit even number of bezier triangles before hitting normal plane
				// this means we are outside the object - render environment color
				payload.directColor = raytracingDataConstants.environmentColor;
				payload.indirectColor = vec3(0.0, 0.0, 0.0);
			}
		}
	}

	vec4 color = vec4(payload.directColor + payload.indirectColor, 1.0);

	if (ubo.frameCount > 0)
	{
		vec4 previousColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy));
		previousColor *= ubo.frameCount;

		color += previousColor;
		color /= (ubo.frameCount + 1);
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), color);
}
