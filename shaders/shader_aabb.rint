#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_debug_printf : enable

// TODO: Figure out what these do
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require


#include "../src/common_types.h"

// TODO; put this in a common file

struct Ray
{
	vec3 origin;
	vec3 direction;
};

layout(set = 0, binding=5, scalar) buffer Tetrahedrons
{
	Tetrahedron[] tetrahedrons;
};

layout(set = 0, binding=6, scalar) buffer Spheres
{
	Sphere[] spheres;
};

// Ray-Sphere intersection
// http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/
float hitSphere(const Sphere s, const Ray r)
{
  vec3  oc           = r.origin - s.center;
  float a            = dot(r.direction, r.direction);
  float b            = 2.0 * dot(oc, r.direction);
  float c            = dot(oc, oc) - s.radius * s.radius;
  float discriminant = b * b - 4 * a * c;
  if(discriminant < 0)
  {
    return -1.0;
  }
  else
  {
    return (-b - sqrt(discriminant)) / (2.0 * a);
  }
}


// Ray-AABB intersection
// float hitAabb(const Aabb aabb, const Ray r)
// {
// 	vec3  invDir = 1.0 / r.direction;
// 	vec3  tbot   = invDir * (aabb.minimum - r.origin);
// 	vec3  ttop   = invDir * (aabb.maximum - r.origin);
// 	vec3  tmin   = min(ttop, tbot);
// 	vec3  tmax   = max(ttop, tbot);
// 	float t0     = max(tmin.x, max(tmin.y, tmin.z));
// 	float t1     = min(tmax.x, min(tmax.y, tmax.z));
// 	return t1 > max(t0, 0.0) ? t0 : -1.0;
// }


float PointInOrOn(vec3 P1, vec3 P2, vec3 A, vec3 B )
{
    vec3 CP1 = cross(B - A, P1 - A);
    vec3 CP2 = cross(B - A, P2 - A);
    return step(0.0, dot(CP1, CP2));
}

float PointInTriangle( vec3 px, vec3 p0, vec3 p1, vec3 p2 )
{
    return 
        PointInOrOn(px, p0, p1, p2) *
        PointInOrOn(px, p1, p2, p0) *
        PointInOrOn(px, p2, p0, p1);
}


vec3 IntersectPlane(Ray ray, vec3 p0, vec3 p1, vec3 p2)
{
    vec3 D = ray.direction;
    vec3 N = cross(p1-p0, p2-p0);
    vec3 X = ray.origin + D * dot(p0 - ray.origin, N) / dot(D, N);

    return X;
}


float IntersectTriangle(Ray ray, vec3 p0, vec3 p1, vec3 p2)
{
    vec3 X = IntersectPlane(ray, p0, p1, p2);

    if(PointInTriangle(X, p0, p1, p2) > 0) {
		// debugPrintfEXT("IntersectPlane: %f, %f, %f", X.x,X.y,X.z);
		float dist = distance(ray.origin, X);
		// debugPrintfEXT("Dist: %f", dist);
		return dist;
	}
	return -1;
}




void main() {
	Ray ray;
	ray.origin    = gl_WorldRayOriginEXT;
	ray.direction = gl_WorldRayDirectionEXT;


	int objectType = gl_InstanceCustomIndexEXT;
	// Tetrahedron data
	Tetrahedron tetrahedron = tetrahedrons[gl_PrimitiveID];

	// debugPrintfEXT("gl_InstanceCustomIndexEXT: %d", gl_InstanceCustomIndexEXT);
	// debugPrintfEXT("Tetrahedron: a: %f, %f, %f", tetrahedron.a.x,tetrahedron.a.y,tetrahedron.a.z);
	// debugPrintfEXT("Tetrahedron: b: %f, %f, %f", tetrahedron.b.x,tetrahedron.b.y,tetrahedron.b.z);
	// debugPrintfEXT("Tetrahedron: c: %f, %f, %f", tetrahedron.c.x,tetrahedron.c.y,tetrahedron.c.z);

	float tHit = -1;
	if(objectType == t_Tetrahedron)
	{
		// // AABB intersection
		// Aabb aabb;
		// aabb.minimum = sphere.center - vec3(sphere.radius);
		// aabb.maximum = sphere.center + vec3(sphere.radius);
		// tHit         = hitAabb(aabb, ray);
		tHit = IntersectTriangle(ray, tetrahedron.a, tetrahedron.b, tetrahedron.c);
	}
	else if (objectType == t_Sphere)
	{
		// Sphere intersection
		Sphere sphere = spheres[gl_PrimitiveID];
		tHit = hitSphere(sphere, ray);
	}else{
		// always mark as hit
		tHit = 1;
	}

	// Report hit point
	if(tHit > 0)
		reportIntersectionEXT(tHit, objectType);

}
