#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_debug_printf : enable

// TODO: Figure out what these do
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "../include/common_types.h"
#include "../include/common_shader_functions.glsl"

// TODO; put this in a common file

bool isCrosshairRay = false;
hitAttributeEXT vec2 hitCoordinate;

layout(set = 0, binding = 5, scalar) buffer Tetrahedrons
{
	Tetrahedron2[] tetrahedrons;
};

layout(set = 0, binding = 6, scalar) buffer Spheres
{
	Sphere[] spheres;
};

layout(set = 0, binding = 7, scalar) buffer RectangularBezierSurfaces
{
	RectangularBezierSurface2x2[] rectangularBezierSurfaces2x2;
};

layout(set = 0, binding = 8, scalar) buffer SlicingPlanes
{
	SlicingPlane[] slicingPlanes;
};

layout(set = 0, binding = 9, scalar) buffer GPUInstances
{
	GPUInstance[] gpuInstances;
};

layout(set = 0, binding = 10, scalar) buffer BezierTriangles2
{
	BezierTriangle2[] bezierTriangles2;
};

layout(push_constant) uniform RaytracingDataConstants{
    // see common_types.h
    PUSH_CONSTANT_MEMBERS} raytracingDataConstants;

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
mat2x2 inverseJacobian(const mat2x2 J)
{
	float d = determinant(J);
	if (abs(d) < 0.00001)
	{
		return mat2x2(0, 0, 0, 0);
	}

	mat2x2 adj = mat2x2(J[1][1], -J[0][1], -J[1][0], J[0][0]);
	mat2x2 mat = 1.0 / d * adj;
	return mat;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Bezier Triangle /////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
vec3 BezierTriangle2Point(const vec3 controlPoints[6], const float u, const float v, const float w)
{
	int n = 2;
	vec3 sum = vec3(0);
	// check if values are in the right range and if sum is equal to 1
	// if (u < 0 || u > 1 || v < 0 || v > 1 || w < 0 || w > 1 || (abs(u + v + w - 1) > 0.00001))
	// {
	// 	return sum;
	// }

	// TODO: remove this loop and write out the formula
	for (int k = 0; k <= n; k++)
	{
		for (int j = 0; j <= n - k; j++)
		{
			for (int i = 0; i <= n - k - j; i++)
			{
				if (i + j + k == n)
				{
					int idx = getControlPointIndicesBezierTriangle2(i, j, k);
					sum += controlPoints[idx] * BernsteinPolynomialBivariate(n, i, j, k, u, v, w);
				}
			}
		}
	}
	return sum;
}

vec2 fBezierTriangle(const vec3[6] controlPoints,
                     const vec3 origin,
                     const vec3 n1,
                     const vec3 n2,
                     const float u,
                     const float v,
                     const float w)
{
	vec3 surfacePoint = BezierTriangle2Point(controlPoints, u, v, w);

	// project onto planes
	float d1 = dot(-n1, origin);
	float d2 = dot(-n2, origin);
	return vec2(dot(n1, surfacePoint) + d1, dot(n2, surfacePoint) + d2);
}

mat2x2 jacobianBezierTriangle2(
    const vec3 controlPoints[6], const vec3 n1, const vec3 n2, const float u, const float v)
{
	vec3 dirU = vec3(1, 0, -1);
	vec3 dirV = vec3(0, 1, -1);
	vec3 partialDerivative1 = partialBezierTriangle2Directional(controlPoints, dirU, u, v);
	vec3 partialDerivative2 = partialBezierTriangle2Directional(controlPoints, dirV, u, v);

	return mat2x2(dot(n1, partialDerivative1),
	              dot(n2, partialDerivative1),
	              dot(n1, partialDerivative2),
	              dot(n2, partialDerivative2));
}

bool newtonsMethodTriangle2(inout vec3 intersectionPoint,
                            const vec2 initialGuess,
                            const vec3 origin,
                            const vec3[6] controlPoints,
                            const vec3 n1,
                            const vec3 n2)
{
	// debug print origin, n1 and n2
	if (isCrosshairRay)
	{
		// debugPrintfEXT("AAAAAAAAAAAAAAAAAAAAAAAAA origin: (%.2v3f), n1: (%.2v3f), n2: (%.2v3f)",
		//                origin,
		//                n1,
		//                n2);
	}

	bool hit = false;
	const int max_iterations = 100 + 1;
	vec2 u[max_iterations];

	float toleranceX = raytracingDataConstants.newtonErrorXTolerance;
	float toleranceF = raytracingDataConstants.newtonErrorFTolerance;

	u[0] = initialGuess;
	for (int c = 1; c < max_iterations; c++)
	{
		u[c] = vec2(0);
	}

	int c = 0;
	//	if (raytracingDataConstants.newtonMaxIterations == 0)
	//	{
	//
	//		if (initialGuess.x >= 0 && initialGuess.y >= 0 && (initialGuess.x + initialGuess.y) <=
	// 1)
	//		{
	//			u[c + 1] = initialGuess;
	//			hit = true;
	//		}
	//	}
	//	else
	//	{
	float previousErrorF = 100000.0;
	float errorF = 100000.0;

	float previousErrorX = 100000.0;
	float errorX = 100000.0;

	for (; c < raytracingDataConstants.newtonMaxIterations; c++)
	{
		mat2x2 j = jacobianBezierTriangle2(controlPoints, n1, n2, u[c].x, u[c].y);
		mat2x2 inv_j = inverseJacobian(j);
		if (inv_j == mat2x2(0, 0, 0, 0))
		{
			if (isCrosshairRay)
			{
				// debugPrintfEXT("abort: inv_j is 0");
			}
			hit = false;
			break;
		}

		vec2 f_value
		    = fBezierTriangle(controlPoints, origin, n1, n2, u[c].x, u[c].y, 1.0 - u[c].x - u[c].y);

		previousErrorF = errorF;
		errorF = abs(f_value.x) + abs(f_value.y);

		vec2 differenceInUV = inv_j * f_value;
		u[c + 1] = u[c] - differenceInUV;

		// previousErrorX = errorX;
		// errorX = abs(differenceInUV.x) + abs(differenceInUV.y);

		if (isCrosshairRay)
		{
			if (raytracingDataConstants.someScalar == c)
			{
				vec3 surfacePoint
				    = BezierTriangle2Point(controlPoints, u[c].x, u[c].y, 1.0 - u[c].x - u[c].y);
				debugPrintfEXT(
				    "c: %d u: 0:(%.2v2f), 1:(%.2v2f), 2:(%.2v2f), 3:(%.2v2f), 4:(%.2v2f), 5:(%.2v2f), 6:(%.2v2f), 7:(%.2v2f), 8:(%.2v2f), 9:(%.2v2f), n1: (%.2v3f), n2: (%.2v3f), f: (%.2v2f), differenceInUV:(%.2v2f), u: (%.2v2f), u+1: (%.2v2f), errorX: (%.5f), errorF: (%.5f),j:(%.2f, %.2f, %.2f, %.2f),  inv_j:(%.2f, %.2f, %.2f, %.2f) surfacePoint (%.2v3f)",
				    c,
				    u[0],
				    u[1],
				    u[2],
				    u[3],
				    u[4],
				    u[5],
				    u[6],
				    u[7],
				    u[8],
				    u[9],
				    n1,
				    n2,
				    f_value,
				    differenceInUV,
				    u[c],
				    u[c + 1],
				    errorX,
				    errorF,
				    j[0][0],
				    j[0][1],
				    j[1][0],
				    j[1][1],
				    inv_j[0][0],
				    inv_j[0][1],
				    inv_j[1][0],
				    inv_j[1][1],
				    surfacePoint);
			}
		}

		if (raytracingDataConstants.newtonErrorFIgnoreIncrease == 0.0 && errorF > previousErrorF)
		{
			if (isCrosshairRay)
			{
				// debugPrintfEXT("abort: errorF increased: errorF: %.8f, previousErrorF: %.8f",
				//                errorF,
				//                previousErrorF);
			}
			hit = false;
			break;
		}

		if (errorF <= toleranceF)
		{
			hit = raytracingDataConstants.newtonErrorFHitBelowTolerance > 0.0;
			if (isCrosshairRay)
			{
				// debugPrintfEXT("hit: errorF <= toleranceF: (%.5f)", errorF);
			}
			break;
		}

		// if (raytracingDataConstants.newtonErrorXIgnoreIncrease == 0.0 && errorX > previousErrorX)
		// {
		// 	if (isCrosshairRay)
		// 	{
		// 		debugPrintfEXT("abort: errorX increased: errorX: %.5f, previousErrorX: %.5f",
		// 		               errorX,
		// 		               previousErrorX);
		// 	}
		// 	hit = false;
		// 	break;
		// }

		// // TODO: maybe we want different tolerances for errorX and errorF
		// if (errorX <= toleranceX)
		// {
		// 	hit = raytracingDataConstants.newtonErrorXHitBelowTolerance > 0.0;
		// 	if (isCrosshairRay)
		// 	{
		// 		debugPrintfEXT("hit: errorX <= toleranceX (%.5f)", errorX);
		// 	}
		// 	break;
		// }
	}
	//	}

	if (isCrosshairRay)
	{
		// debugPrintfEXT("loop ended: hit: %d", hit);
	}

	intersectionPoint = vec3(0);
	if (hit)
	{
		int idx = c;

		if (u[idx].x < 0 || u[idx].y < 0 || (u[idx].x + u[idx].y) > 1)
		{
			hit = false;
			return hit;
		}

		intersectionPoint
		    = BezierTriangle2Point(controlPoints, u[idx].x, u[idx].y, 1.0 - u[idx].x - u[idx].y);
		if (isCrosshairRay)
		{
			// debugPrintfEXT("u: (%.2v2f), intersectionPoint: (%.2v3f)", u[idx],
			// intersectionPoint);
		}
		hitCoordinate = vec2(u[idx].x, u[idx].y);
	}
	return hit;
}

void main()
{
	// Debugging, display aabb boxes
	if (raytracingDataConstants.debugShowAABBs > 0.0)
	{
		// here we should actually calculate the intersection with the AABB but
		// for simple debugging this is enough to show the AABBs
		reportIntersectionEXT(0.001, t_AABBDebug);
		return;
	}

	Ray ray;
	ray.origin = gl_WorldRayOriginEXT;
	ray.direction = gl_WorldRayDirectionEXT;

	GPUInstance instance = gpuInstances[gl_InstanceCustomIndexEXT];
	int objectType = instance.type;

	vec3 cameraDir = raytracingDataConstants.cameraDir;
	// whether or not the current ray direction is the crosshair's direction
	if (abs(dot(normalize(ray.direction), normalize(cameraDir)) - 1) < 0.0000001)
	{
		isCrosshairRay = true;
	}

	isCrosshairRay = raytracingDataConstants.debugPrintCrosshairRay > 0.0 && isCrosshairRay;

	// debugPrintfEXT("istanceCustomIndexEXT: %d primitiveID: %d ObjectType: %d",
	//                gl_InstanceCustomIndexEXT,
	//                gl_PrimitiveID,
	//                objectType);

	// Tetrahedron data

	// debugPrintfEXT("gl_InstanceCustomIndexEXT: %d", gl_InstanceCustomIndexEXT);
	// debugPrintfEXT("Tetrahedron: a: %f, %f, %f",
	// tetrahedron.a.x,tetrahedron.a.y,tetrahedron.a.z); debugPrintfEXT("Tetrahedron: b: %f, %f,
	// %f", tetrahedron.b.x,tetrahedron.b.y,tetrahedron.b.z); debugPrintfEXT("Tetrahedron: c: %f,
	// %f, %f", tetrahedron.c.x,tetrahedron.c.y,tetrahedron.c.z);

	float tHit = -1;
	vec3 intersectionPoint = vec3(0);
	if (objectType == t_Tetrahedron1)
	{
	}
	else if (objectType == t_BezierTriangle2)
	{
		BezierTriangle2 bezierTriangle = bezierTriangles2[instance.bufferIndex];

		vec3 o = ray.origin;
		vec3 n1, n2;

		float dx = ray.direction.x;
		float dy = ray.direction.y;
		float dz = ray.direction.z;

		// if (abs(dx) > abs(dy) && abs(dx) > abs(dz))
		// {
		// 	n1 = vec3(dy, -dx, 0);
		// }
		// else
		// {
		// 	n1 = vec3(0, dz, -dy);
		// }
		// n2 = cross(n1, ray.direction);

		vec3 v = (abs(ray.direction.y) < 0.99) ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);
		n1 = normalize(cross(ray.direction, v));
		n2 = normalize(cross(ray.direction, n1));

		if (isCrosshairRay)
		{
			// debugPrintfEXT("n1: (%.8v3f), n2: (%.8v3f)", n1, n2);
		}

		// debugPrintfEXT("v0: (%.2v3f), v1: (%.2v3f), v2: (%.2v3f)", v0, v1, v2);

		float t;
		if (raytracingDataConstants.renderSideTriangle > 0.0)
		{

			vec3 v0 = bezierTriangle.controlPoints[getControlPointIndicesBezierTriangle2(0, 0, 2)];
			vec3 v1 = bezierTriangle.controlPoints[getControlPointIndicesBezierTriangle2(0, 2, 0)];
			vec3 v2 = bezierTriangle.controlPoints[getControlPointIndicesBezierTriangle2(2, 0, 0)];

			// vec2 triangleIntersect = vec2(0, 0);
			// {
			// 	float t;
			// 	if (IntersectTriangle(ray.origin, ray.direction, v0, v1, v2, t))
			// 	{
			// 		vec3 p = o + ray.direction * t;
			// 		vec3 a = v1 - v0;
			// 		vec3 b = v2 - v0;
			// 		vec3 c = p - v0;

			// 		float dot00 = dot(a, a);
			// 		float dot01 = dot(a, b);
			// 		float dot11 = dot(b, b);
			// 		float dot20 = dot(c, a);
			// 		float dot21 = dot(c, b);
			// 		float denom = dot00 * dot11 - dot01 * dot01;
			// 		float v = (dot11 * dot20 - dot01 * dot21) / denom;
			// 		float w = (dot00 * dot21 - dot01 * dot20) / denom;
			// 		float alpha = 1.0 - v - w;
			// 		float beta = v;
			// 		float gamma = w;

			// 		triangleIntersect = vec2(gamma, beta);
			// 		if (isCrosshairRay)
			// 		{
			// 			debugPrintfEXT("triangleIntersect: (%.2v2f)", triangleIntersect);
			// 		}
			// 	}
			// }

			vec2 guesses[6] = {
			    vec2(0, 0), vec2(0, 1), vec2(1, 0), vec2(.5, 0), vec2(0, .5), vec2(.5, .5),
			    // triangleIntersect,
			};

			for (int i = 0; i < 6; i++)
			{
				vec2 guess = guesses[i];
				if (newtonsMethodTriangle2(
				        intersectionPoint, guess, o, bezierTriangle.controlPoints, n1, n2))
				{
					float dist = distance(intersectionPoint, o);
					tHit = dist;
					break;
				}
			}
		}
	}
	else if (objectType == t_Tetrahedron2)
	{
		// Tetrahedron2 tetrahedron = tetrahedrons[instance.bufferIndex];
	}
	else if (objectType == t_Triangle)
	{
		// Triangle triangle = triangles[instance.bufferIndex];
		// tHit = IntersectTriangle(ray, triangle.a, triangle.b, triangle.c);
	}
	else if (objectType == t_Sphere)
	{
		// Sphere intersection
		Sphere sphere = spheres[instance.bufferIndex];
		if (isCrosshairRay)
		{
			debugPrintfEXT("sphere buffer index: %d sphere: radius: %f pos: %.2v3f color: %d ",
			               instance.bufferIndex,
			               sphere.radius,
			               sphere.center,
			               sphere.colorIdx);
		}

		tHit = hitSphere(sphere, ray);
	}
	else if (objectType == t_RectangularBezierSurface2x2)
	{
	}
	else
	{
		// always mark as hit
		tHit = 1;
	}

	if (raytracingDataConstants.enableSlicingPlanes > 0.0)
	{
		// if we still hit no object, check if we hit a slicing plane
		const int SLICING_PLANE_MAX_COUNT = 2;
		float oldTHit = tHit;

		bool showSlicingPlanes = raytracingDataConstants.debugSlicingPlanes > 0.0;
		for (int idx = 0; idx < SLICING_PLANE_MAX_COUNT; idx++)
		{
			SlicingPlane plane = slicingPlanes[idx];
			float t = 0;

			if (oldTHit > 0 && dot(intersectionPoint - plane.planeOrigin, plane.normal) >= 0)
			{
				if (showSlicingPlanes)
				{
					if (intersectWithPlane(
					        plane.normal, plane.planeOrigin, ray.origin, ray.direction, t)
					    && tHit > 0 && tHit < t)
					{
						tHit = t;
						objectType = int(t_SlicingPlane);
					}
				}
				else
				{
					tHit = -1;
				}
				objectType = int(t_SlicingPlane);
			}
		}
	}

	// Report hit point
	if (tHit > 0) reportIntersectionEXT(tHit, objectType);
}
