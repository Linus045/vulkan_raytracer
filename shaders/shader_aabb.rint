#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_debug_printf : enable

// TODO: Figure out what these do
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "../include/common_types.h"
#include "../include/common_shader_functions.glsl"

// TODO; put this in a common file

struct HitData
{
	vec3 point;
	vec2 coords;
	vec3 normal;
};

bool isCrosshairRay = false;
hitAttributeEXT HitData hitData;

layout(set = 0, binding = 1) uniform UBO{// see common_types.h
                                         UNIFORM_MEMBERS} ubo;

layout(set = 0, binding = 5, scalar) buffer Tetrahedrons
{
	Tetrahedron2[] tetrahedrons;
};

layout(set = 0, binding = 6, scalar) buffer Spheres
{
	Sphere[] spheres;
};

layout(set = 0, binding = 7, scalar) buffer RectangularBezierSurfaces
{
	RectangularBezierSurface2x2[] rectangularBezierSurfaces2x2;
};

layout(set = 0, binding = 8, scalar) buffer SlicingPlanes
{
	SlicingPlane[] slicingPlanes;
};

layout(set = 0, binding = 9, scalar) buffer GPUInstances
{
	GPUInstance[] gpuInstances;
};

layout(set = 0, binding = 10, scalar) buffer BezierTriangles2
{
	BezierTriangle2[] bezierTriangles2;
};

layout(push_constant) uniform RaytracingDataConstants{
    // see common_types.h
    PUSH_CONSTANT_MEMBERS} raytracingDataConstants;

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
mat2x2 inverseJacobian(const mat2x2 J)
{
	float d = determinant(J);
	if (abs(d) < 0.00001)
	{
		return mat2x2(0, 0, 0, 0);
	}

	mat2x2 adj = mat2x2(J[1][1], -J[0][1], -J[1][0], J[0][0]);
	mat2x2 mat = 1.0 / d * adj;
	return mat;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Bezier Triangle /////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
vec3 BezierTriangle2Point(const vec3 controlPoints[6], const float u, const float v, const float w)
{
	int n = 2;
	vec3 sum = vec3(0);
	// check if values are in the right range and if sum is equal to 1
	// if (u < 0 || u > 1 || v < 0 || v > 1 || w < 0 || w > 1 || (abs(u + v + w - 1) > 0.00001))
	// {
	// 	return sum;
	// }

	// TODO: remove this loop and write out the formula
	for (int k = 0; k <= n; k++)
	{
		for (int j = 0; j <= n - k; j++)
		{
			for (int i = 0; i <= n - k - j; i++)
			{
				if (i + j + k == n)
				{
					int idx = getControlPointIndicesBezierTriangle2(i, j, k);
					sum += controlPoints[idx] * BernsteinPolynomialBivariate(n, i, j, k, u, v, w);
				}
			}
		}
	}
	return sum;
}

vec2 fBezierTriangle(const vec3[6] controlPoints,
                     const vec3 origin,
                     const vec3 n1,
                     const vec3 n2,
                     const float u,
                     const float v,
                     const float w)
{
	vec3 surfacePoint = BezierTriangle2Point(controlPoints, u, v, w);

	// project onto planes
	float d1 = dot(-n1, origin);
	float d2 = dot(-n2, origin);
	return vec2(dot(n1, surfacePoint) + d1, dot(n2, surfacePoint) + d2);
}

mat2x2 jacobianBezierTriangle2(const vec3 controlPoints[6],
                               const vec3 n1,
                               const vec3 n2,
                               const float u,
                               const float v,
                               out vec3 partialU,
                               out vec3 partialV)
{
	vec3 dirU = vec3(1, 0, -1);
	vec3 dirV = vec3(0, 1, -1);
	partialU = partialBezierTriangle2Directional(controlPoints, dirU, u, v);
	partialV = partialBezierTriangle2Directional(controlPoints, dirV, u, v);

	return mat2x2(dot(n1, partialU), dot(n2, partialU), dot(n1, partialV), dot(n2, partialV));
}

bool newtonsMethodTriangle2(out vec3 hitPoint,
                            out vec2 hitCoords,
                            out vec3 hitNormal,
                            const vec2 initialGuess,
                            const vec3 rayOrigin,
                            const vec3 rayDirection,
                            const vec3[6] controlPoints,
                            const vec3 n1,
                            const vec3 n2)
{
	bool hit = false;
	const int max_iterations = MAX_NEWTON_ITERATIONS + 1;
	vec2 u[max_iterations];

	float toleranceF = raytracingDataConstants.newtonErrorFTolerance;
	if (raytracingDataConstants.debugFastRenderMode > 0.0 && ubo.frameCount < 10)
	{
		toleranceF = 100000;
	}

	u[0] = initialGuess;
	for (int c = 1; c < max_iterations; c++)
	{
		u[c] = vec2(0);
	}

	int c = 0;
	float previousErrorF = 100000.0;
	float errorF = 100000.0;

	vec3 partialU = vec3(0);
	vec3 partialV = vec3(0);
	for (; c < raytracingDataConstants.newtonMaxIterations; c++)
	{
		mat2x2 j
		    = jacobianBezierTriangle2(controlPoints, n1, n2, u[c].x, u[c].y, partialU, partialV);
		mat2x2 inv_j = inverseJacobian(j);
		if (inv_j == mat2x2(0, 0, 0, 0))
		{
			hit = false;
			break;
		}

		vec2 f_value = fBezierTriangle(
		    controlPoints, rayOrigin, n1, n2, u[c].x, u[c].y, 1.0 - u[c].x - u[c].y);

		previousErrorF = errorF;
		errorF = abs(f_value.x) + abs(f_value.y);

		vec2 differenceInUV = inv_j * f_value;
		u[c + 1] = u[c] - differenceInUV;

		if (errorF <= toleranceF)
		{
			hit = true;
			break;
		}
	}

	if (hit)
	{
		// TODO: why not c+1 ? -> because f_value is calculated for u[c] and not u[c+1]
		const int idx = c;
		if (u[idx].x < 0 || u[idx].y < 0 || (u[idx].x + u[idx].y) > 1)
		{
			hit = false;
			return hit;
		}

		vec3 pointOnSurface
		    = BezierTriangle2Point(controlPoints, u[idx].x, u[idx].y, 1.0 - u[idx].x - u[idx].y);

		// make sure hitPos is in front of ray
		if (dot(pointOnSurface - rayOrigin, rayDirection) > 0)
		{
			hitPoint = pointOnSurface;
			hitCoords = vec2(u[idx].x, u[idx].y);
			hitNormal = normalize(cross(partialU, partialV));
		}
		else
		{
			hit = false;
			return hit;
		}
	}
	return hit;
}

void main()
{
	// Debugging, display aabb boxes
	if (raytracingDataConstants.debugShowAABBs > 0.0)
	{
		// here we should actually calculate the intersection with the AABB but
		// for simple debugging this is enough to show the AABBs

		// NOTE: this fake hit distance must be greater than the tMin in the traceRayEXT used in the
		// rGen shader
		reportIntersectionEXT(0.1, t_AABBDebug);
		return;
	}

	Ray ray;
	ray.origin = gl_WorldRayOriginEXT;
	ray.direction = gl_WorldRayDirectionEXT;

	GPUInstance instance = gpuInstances[gl_InstanceCustomIndexEXT];
	int objectType = instance.type;

	vec3 cameraDir = raytracingDataConstants.cameraDir;
	// whether or not the current ray direction is the crosshair's direction
	if (abs(dot(normalize(ray.direction), normalize(cameraDir)) - 1) < 0.0000001)
	{
		isCrosshairRay = true;
	}

	isCrosshairRay = raytracingDataConstants.debugPrintCrosshairRay > 0.0 && isCrosshairRay;

	// debugPrintfEXT("istanceCustomIndexEXT: %d primitiveID: %d ObjectType: %d",
	//                gl_InstanceCustomIndexEXT,
	//                gl_PrimitiveID,
	//                objectType);

	// Tetrahedron data

	// debugPrintfEXT("gl_InstanceCustomIndexEXT: %d", gl_InstanceCustomIndexEXT);
	// debugPrintfEXT("Tetrahedron: a: %f, %f, %f",
	// tetrahedron.a.x,tetrahedron.a.y,tetrahedron.a.z); debugPrintfEXT("Tetrahedron: b: %f, %f,
	// %f", tetrahedron.b.x,tetrahedron.b.y,tetrahedron.b.z); debugPrintfEXT("Tetrahedron: c: %f,
	// %f, %f", tetrahedron.c.x,tetrahedron.c.y,tetrahedron.c.z);

	float tHit = -1;
	if (objectType == t_BezierTriangle2)
	{
		BezierTriangle2 bezierTriangle = bezierTriangles2[instance.bufferIndex];

		vec3 n1, n2;

		float dx = ray.direction.x;
		float dy = ray.direction.y;
		float dz = ray.direction.z;

		vec3 v = (abs(ray.direction.y) < 0.99) ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);
		n1 = normalize(cross(ray.direction, v));
		n2 = normalize(cross(ray.direction, n1));

		float t;
		if (raytracingDataConstants.renderSideTriangle > 0.0)
		{
			// TODO: figure out what the best guess would be
			const vec2 guesses[6] = {
			    vec2(0, 0),
			    vec2(0, 1),
			    vec2(1, 0),
			    vec2(.5, 0),
			    vec2(0, .5),
			    vec2(.5, .5),
			};

			vec3 hitPoint = vec3(0);
			vec2 hitCoords = vec2(0);
			vec3 hitNormal = vec3(0);

			for (int i = 0; i < 6; i++)
			{
				const vec2 guess = guesses[i];
				if (newtonsMethodTriangle2(hitPoint,
				                           hitCoords,
				                           hitNormal,
				                           guess,
				                           ray.origin,
				                           ray.direction,
				                           bezierTriangle.controlPoints,
				                           n1,
				                           n2))
				{
					bool hitValid = true;
					// check if hit point is in front of the slicing plane,
					// if so, ignore the hit and search for a different point
					if (raytracingDataConstants.enableSlicingPlanes > 0.0)
					{
						bool inFrontOfSlicingPlane = false;
						// if we still hit no object, check if we hit a slicing plane
						const int SLICING_PLANE_MAX_COUNT = 1;

						for (int idx = 0; idx < SLICING_PLANE_MAX_COUNT; idx++)
						{
							SlicingPlane plane = slicingPlanes[idx];
							if (hitPosInFrontOfPlane(plane, hitPoint, ray))
							{
								// ignore hit
								hitValid = false;
								continue;
							}
							else
							{
								hitValid = true;
							}
						}
					}

					if (hitValid)
					{
						float dist = distance(hitPoint, ray.origin);
						// if point is closer to camera, update values
						if (tHit < 0 || dist < tHit)
						{
							tHit = dist;

							hitData.point = hitPoint;
							hitData.coords = hitCoords;
							hitData.normal = hitNormal;
						}
					}
				}
			}
		}
	}
	else if (objectType == t_Sphere)
	{
		// Sphere intersection
		Sphere sphere = spheres[instance.bufferIndex];

		if (isCrosshairRay)
		{
			debugPrintfEXT("sphere buffer index: %d sphere: radius: %f pos: %.2v3f color: %d ",
			               instance.bufferIndex,
			               sphere.radius,
			               sphere.center,
			               sphere.colorIdx);
		}

		bool isShadowRay = ((gl_IncomingRayFlagsEXT & gl_RayFlagsSkipClosestHitShaderEXT) > 0);
		// first sphere is the light sphere, we want to ignore it for shadow test rays
		if (instance.bufferIndex == 0 && isShadowRay)
		{
			// ignore hit if its the shadow test ray
			tHit = -1;
		}
		else
		{

			tHit = hitSphere(sphere, ray);
			if (tHit > 0)
			{
				hitData.point = ray.origin + tHit * ray.direction;
				hitData.normal = hitData.point - sphere.center;
			}
		}
	}
	else
	{
		// always mark as hit
		tHit = 1;
	}

	// Report hit point
	if (tHit > 0) reportIntersectionEXT(tHit, objectType);
}
