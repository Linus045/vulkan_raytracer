#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_debug_printf : enable

// TODO: Figure out what these do
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require


#include "../src/common_types.h"

// TODO; put this in a common file

struct Ray
{
	vec3 origin;
	vec3 direction;
};

layout(set = 0, binding=5, scalar) buffer Tetrahedrons
{
	Tetrahedron[] tetrahedrons;
};

layout(set = 0, binding=6, scalar) buffer Spheres
{
	Sphere[] spheres;
};

layout(set = 0, binding=7, scalar) buffer RectangularBezierSurfaces
{
	RectangularBezierSurface2x2[] rectangularBezierSurfaces2x2;
};

// Ray-Sphere intersection
// http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/
float hitSphere(const Sphere s, const Ray r)
{
  vec3  oc           = r.origin - s.center;
  float a            = dot(r.direction, r.direction);
  float b            = 2.0 * dot(oc, r.direction);
  float c            = dot(oc, oc) - s.radius * s.radius;
  float discriminant = b * b - 4 * a * c;
  if(discriminant < 0)
  {
    return -1.0;
  }
  else
  {
    return (-b - sqrt(discriminant)) / (2.0 * a);
  }
}


// Ray-AABB intersection
// float hitAabb(const Aabb aabb, const Ray r)
// {
// 	vec3  invDir = 1.0 / r.direction;
// 	vec3  tbot   = invDir * (aabb.minimum - r.origin);
// 	vec3  ttop   = invDir * (aabb.maximum - r.origin);
// 	vec3  tmin   = min(ttop, tbot);
// 	vec3  tmax   = max(ttop, tbot);
// 	float t0     = max(tmin.x, max(tmin.y, tmin.z));
// 	float t1     = min(tmax.x, min(tmax.y, tmax.z));
// 	return t1 > max(t0, 0.0) ? t0 : -1.0;
// }


float PointInOrOn(vec3 P1, vec3 P2, vec3 A, vec3 B )
{
    vec3 CP1 = cross(B - A, P1 - A);
    vec3 CP2 = cross(B - A, P2 - A);
    return step(0.0, dot(CP1, CP2));
}

float PointInTriangle( vec3 px, vec3 p0, vec3 p1, vec3 p2 )
{
    return 
        PointInOrOn(px, p0, p1, p2) *
        PointInOrOn(px, p1, p2, p0) *
        PointInOrOn(px, p2, p0, p1);
}


vec3 IntersectPlane(Ray ray, vec3 p0, vec3 p1, vec3 p2)
{
    vec3 D = ray.direction;
    vec3 N = cross(p1-p0, p2-p0);
    vec3 X = ray.origin + D * dot(p0 - ray.origin, N) / dot(D, N);

    return X;
}


float IntersectTriangle(Ray ray, vec3 p0, vec3 p1, vec3 p2)
{
    vec3 X = IntersectPlane(ray, p0, p1, p2);

    if(PointInTriangle(X, p0, p1, p2) > 0) {
		// debugPrintfEXT("IntersectPlane: %f, %f, %f", X.x,X.y,X.z);
		float dist = distance(ray.origin, X);
		// debugPrintfEXT("Dist: %f", dist);
		return dist;
	}
	return -1;
}



//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

float nChooseK(int N, int K)
{
	// This function gets the total number of unique combinations based upon N and K.
	// N is the total number of items.
	// K is the size of the group.
	// Total number of unique combinations = N! / ( K! (N - K)! ).
	// This function is less efficient, but is more likely to not overflow when N and K are large.
	// Taken from:  http://blog.plover.com/math/choose.html
	//
	int r = 1;
	int d;
	if (K > N) return 0;
	for (d = 1; d <= K; d++)
	{
		r *= N--;
		r /= d;
	}
	return r;
}


float realPolynomial(int i, int n, float x)
{
	return nChooseK(n, i) * pow(x, i) * pow(1 - x, n - i);
}

int convert2Dto1D_index(int columns, int i, int j)
{
	return i * columns + j;
}

vec3 bezierSurfacePoint(const vec3 controlPoints[16], int n, int m, float u, float v)
{
	vec3 sum = vec3(0,0,0);
	for (int i = 0; i <= n; i++)
	{
		for (int j = 0; j <= m; j++)
		{
			int idx = convert2Dto1D_index(n + 1, i, j);
			sum += controlPoints[idx]
				* realPolynomial(i, n, u) * realPolynomial(j, m, v);
		}
	}
	return sum;
}

vec3 partialDerivativeBezierSurfaceU(const vec3 controlPoints[16], int n, int m, float u, float v)
{
	vec3 sum = vec3(0,0,0);
	for (int i = 0; i <= n - 1; i++)
	{
		for (int j = 0; j <= m; j++)
		{
			int p_a = convert2Dto1D_index(n + 1, i + 1, j);
			int p_b = convert2Dto1D_index(n + 1, i, j);
			sum += (controlPoints[p_a] - controlPoints[p_b])
				* realPolynomial(i, n - 1, u) * realPolynomial(j, m, v);
		}
	};

	return m * sum;
}

vec3 partialDerivativeBezierSurfaceV(const vec3 controlPoints[16], int n, int m, float u, float v)
{
	vec3 sum = vec3(0,0,0);
	for (int i = 0; i <= n; i++)
	{
		for (int j = 0; j <= m - 1; j++)
		{
			int p_a = convert2Dto1D_index(n + 1, i, j + 1);
			int p_b = convert2Dto1D_index(n + 1, i, j);
			sum += (controlPoints[p_a] - controlPoints[p_b])
				* realPolynomial(i, n, u) * realPolynomial(j, m - 1, v);
		}
	};

	return n * sum;
}

vec2 projectPoint(const vec3 point, const vec3 origin, const vec3 n1, const vec3 n2)
{
	return vec2(dot(point, n1) - dot(n1, origin),
			dot(point, n2) - dot(n2, origin));
}



mat2x2 jacobian(const vec3 controlPoints[16],
		const int n,
		const int m,
		const vec3 n1,
		const vec3 n2,
		const float u,
		const float v)
{
	vec3 partialDerivtiveU = partialDerivativeBezierSurfaceU(controlPoints, n, m, u, v);
	vec3 partialDerivativeV = partialDerivativeBezierSurfaceV(controlPoints, n, m, u, v);
	return mat2x2(
		dot(n1, partialDerivtiveU),
			dot(n1, partialDerivativeV),
			dot(n2, partialDerivtiveU),
			dot(n2, partialDerivativeV)
	);
}

mat2x2 inverseJacobian(const mat2x2 J) {
	float d = determinant(J);
	if(abs(d) < 0.00001) {
		return mat2x2(0,0,0,0);
	}

	mat2x2 mat = 1.0f / d * mat2x2(
			J[1][1],
			-J[0][1],
			-J[1][0],
			J[0][0]
		);
	return mat;
}

vec2 f(const vec3 controlPoints[16],
		const vec3 origin,
		const int n,
		const int m,
		const vec3 n1,
		const vec3 n2,
		const float u,
		const float v)
{
	vec3 surfacePoint = bezierSurfacePoint(controlPoints, n, m, u, v);
	float d1 = dot(-n1, origin);
	float d2 = dot(-n2, origin);
	return vec2(
			dot(n1, surfacePoint) + d1, 
			dot(n2, surfacePoint) + d2
			);
}



bool newtonsMethod(inout vec3 intersectionPoint,
		const vec2 initialGuess,
		const vec3 origin,
		const vec3 controlPoints[16],
		int n,
		int m,
		const vec3 n1,
		const vec3 n2)
{
	intersectionPoint = vec3(0,0,0);

	// vec2 initialGuess = vec2(0.5, 0.2);
	const int max_iterations = 10;
	vec2 u[max_iterations + 1];

	vec2 tolerance = vec2(0.002f, 0.002f);

	u[0] = initialGuess;

	vec2 previousError = vec2(0,0);
	vec2 error = vec2(100000, 100000);

	for (int c = 0; c < max_iterations; c++)
	{
		// WARN: IDK if jacobian is calculated correctly
		mat2x2 j = jacobian(controlPoints, n, m, n1, n2, u[c].x, u[c].y);
		mat2x2 inv_j = inverseJacobian(j);
		if(inv_j == mat2x2(0,0,0,0)) {
			intersectionPoint = vec3(0,0,0);
			return false;
		}

		vec2 f_value = f(controlPoints, origin, n, m, n1, n2, u[c].x, u[c].y);

		vec2 differenceInUV = (inv_j * f_value);
		u[c + 1] = u[c] - differenceInUV;
		previousError = error;
		error = abs(f_value);

		if (error.x < tolerance.x && error.t < tolerance.y)
		{
			intersectionPoint = bezierSurfacePoint(controlPoints, n, m, u[c].x, u[c].y);
			return true;
		}

		if (length(error) > length(previousError))
		{
			return false;
		}
	}

	return false;
}


void main() {
	Ray ray;
	ray.origin    = gl_WorldRayOriginEXT;
	ray.direction = gl_WorldRayDirectionEXT;


	int objectType = gl_InstanceCustomIndexEXT;
	// Tetrahedron data
	Tetrahedron tetrahedron = tetrahedrons[gl_PrimitiveID];

	// debugPrintfEXT("gl_InstanceCustomIndexEXT: %d", gl_InstanceCustomIndexEXT);
	// debugPrintfEXT("Tetrahedron: a: %f, %f, %f", tetrahedron.a.x,tetrahedron.a.y,tetrahedron.a.z);
	// debugPrintfEXT("Tetrahedron: b: %f, %f, %f", tetrahedron.b.x,tetrahedron.b.y,tetrahedron.b.z);
	// debugPrintfEXT("Tetrahedron: c: %f, %f, %f", tetrahedron.c.x,tetrahedron.c.y,tetrahedron.c.z);

	float tHit = -1;
	if(objectType == t_Tetrahedron)
	{
		// // AABB intersection
		// Aabb aabb;
		// aabb.minimum = sphere.center - vec3(sphere.radius);
		// aabb.maximum = sphere.center + vec3(sphere.radius);
		// tHit         = hitAabb(aabb, ray);
		tHit = IntersectTriangle(ray, tetrahedron.a, tetrahedron.b, tetrahedron.c);
	}
	else if (objectType == t_Sphere)
	{
		// Sphere intersection
		Sphere sphere = spheres[gl_PrimitiveID];
		tHit = hitSphere(sphere, ray);
	}
	else if (objectType == t_RectangularBezierSurface2x2)
	{
		RectangularBezierSurface2x2 surface = rectangularBezierSurfaces2x2[gl_PrimitiveID];
		vec3 o = ray.origin;
		vec3 n1, n2;

		float dx = ray.direction.x;
		float dy = ray.direction.y;
		float dz = ray.direction.z;

		if(abs(dx) > abs(dy) && abs(dx) > abs(dz)) {
			n1 = vec3(dy, -dx, 0);
		}else{
			n1 = vec3(0, dz, -dy);
		}
		n2 = cross(n1, ray.direction);

		vec3 intersectionPoint;
		// TODO: figure out what a good intial guess is
		// vec2 initialGuess = projectPoint(surface.controlPoints[10].xyz, o, n1, n2);
		vec2 initialGuess = vec2(1,1.0);
		if (newtonsMethod(intersectionPoint, initialGuess, ray.origin, surface.controlPoints, 3, 3, n1, n2))
		{
			tHit = distance(intersectionPoint, ray.origin);
		}
	}
	else
	{
		// always mark as hit
		tHit = 1;
	}

	// Report hit point
	if(tHit > 0)
		reportIntersectionEXT(tHit, objectType);

}
