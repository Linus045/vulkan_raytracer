#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_debug_printf : enable

// TODO: Figure out what these do
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "../include/common_types.h"
#include "../include/common_shader_functions.glsl"

// TODO; put this in a common file

struct HitData
{
	vec2 hitCoord;
	bool inFrontOfSlicingPlane;
};

bool isCrosshairRay = false;
hitAttributeEXT HitData hitCoordinate;

layout(set = 0, binding = 5, scalar) buffer Tetrahedrons
{
	Tetrahedron2[] tetrahedrons;
};

layout(set = 0, binding = 6, scalar) buffer Spheres
{
	Sphere[] spheres;
};

layout(set = 0, binding = 7, scalar) buffer RectangularBezierSurfaces
{
	RectangularBezierSurface2x2[] rectangularBezierSurfaces2x2;
};

layout(set = 0, binding = 8, scalar) buffer SlicingPlanes
{
	SlicingPlane[] slicingPlanes;
};

layout(set = 0, binding = 9, scalar) buffer GPUInstances
{
	GPUInstance[] gpuInstances;
};

layout(set = 0, binding = 10, scalar) buffer BezierTriangles2
{
	BezierTriangle2[] bezierTriangles2;
};

layout(push_constant) uniform RaytracingDataConstants{
    // see common_types.h
    PUSH_CONSTANT_MEMBERS} raytracingDataConstants;

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
mat2x2 inverseJacobian(const mat2x2 J)
{
	float d = determinant(J);
	if (abs(d) < 0.00001)
	{
		return mat2x2(0, 0, 0, 0);
	}

	mat2x2 adj = mat2x2(J[1][1], -J[0][1], -J[1][0], J[0][0]);
	mat2x2 mat = 1.0 / d * adj;
	return mat;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Bezier Triangle /////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
vec3 BezierTriangle2Point(const vec3 controlPoints[6], const float u, const float v, const float w)
{
	int n = 2;
	vec3 sum = vec3(0);
	// check if values are in the right range and if sum is equal to 1
	// if (u < 0 || u > 1 || v < 0 || v > 1 || w < 0 || w > 1 || (abs(u + v + w - 1) > 0.00001))
	// {
	// 	return sum;
	// }

	// TODO: remove this loop and write out the formula
	for (int k = 0; k <= n; k++)
	{
		for (int j = 0; j <= n - k; j++)
		{
			for (int i = 0; i <= n - k - j; i++)
			{
				if (i + j + k == n)
				{
					int idx = getControlPointIndicesBezierTriangle2(i, j, k);
					sum += controlPoints[idx] * BernsteinPolynomialBivariate(n, i, j, k, u, v, w);
				}
			}
		}
	}
	return sum;
}

vec2 fBezierTriangle(const vec3[6] controlPoints,
                     const vec3 origin,
                     const vec3 n1,
                     const vec3 n2,
                     const float u,
                     const float v,
                     const float w)
{
	vec3 surfacePoint = BezierTriangle2Point(controlPoints, u, v, w);

	// project onto planes
	float d1 = dot(-n1, origin);
	float d2 = dot(-n2, origin);
	return vec2(dot(n1, surfacePoint) + d1, dot(n2, surfacePoint) + d2);
}

mat2x2 jacobianBezierTriangle2(
    const vec3 controlPoints[6], const vec3 n1, const vec3 n2, const float u, const float v)
{
	vec3 dirU = vec3(1, 0, -1);
	vec3 dirV = vec3(0, 1, -1);
	vec3 partialDerivative1 = partialBezierTriangle2Directional(controlPoints, dirU, u, v);
	vec3 partialDerivative2 = partialBezierTriangle2Directional(controlPoints, dirV, u, v);

	return mat2x2(dot(n1, partialDerivative1),
	              dot(n2, partialDerivative1),
	              dot(n1, partialDerivative2),
	              dot(n2, partialDerivative2));
}

bool newtonsMethodTriangle2(inout vec3 intersectionPoint,
                            inout vec2 hitCoord,
                            const vec2 initialGuess,
                            const vec3 origin,
                            const vec3[6] controlPoints,
                            const vec3 n1,
                            const vec3 n2)
{
	bool hit = false;
	const int max_iterations = MAX_NEWTON_ITERATIONS + 1;
	vec2 u[max_iterations];

	float toleranceF = raytracingDataConstants.newtonErrorFTolerance;

	u[0] = initialGuess;
	for (int c = 1; c < max_iterations; c++)
	{
		u[c] = vec2(0);
	}

	int c = 0;
	float previousErrorF = 100000.0;
	float errorF = 100000.0;

	for (; c < MAX_NEWTON_ITERATIONS; c++)
	{
		mat2x2 j = jacobianBezierTriangle2(controlPoints, n1, n2, u[c].x, u[c].y);
		mat2x2 inv_j = inverseJacobian(j);
		if (inv_j == mat2x2(0, 0, 0, 0))
		{
			hit = false;
			break;
		}

		vec2 f_value
		    = fBezierTriangle(controlPoints, origin, n1, n2, u[c].x, u[c].y, 1.0 - u[c].x - u[c].y);

		previousErrorF = errorF;
		errorF = abs(f_value.x) + abs(f_value.y);

		vec2 differenceInUV = inv_j * f_value;
		u[c + 1] = u[c] - differenceInUV;

		if (errorF <= toleranceF)
		{
			hit = true;
			break;
		}
	}

	intersectionPoint = vec3(0);
	if (hit)
	{
		// TODO: why not c+1 ?
		const int idx = c;
		if (u[idx].x < 0 || u[idx].y < 0 || (u[idx].x + u[idx].y) > 1)
		{
			hit = false;
			return hit;
		}

		intersectionPoint
		    = BezierTriangle2Point(controlPoints, u[idx].x, u[idx].y, 1.0 - u[idx].x - u[idx].y);
		hitCoordinate.hitCoord = vec2(u[idx].x, u[idx].y);
	}
	return hit;
}

void main()
{
	// Debugging, display aabb boxes
	if (raytracingDataConstants.debugShowAABBs > 0.0)
	{
		// here we should actually calculate the intersection with the AABB but
		// for simple debugging this is enough to show the AABBs
		reportIntersectionEXT(0.001, t_AABBDebug);
		return;
	}

	Ray ray;
	ray.origin = gl_WorldRayOriginEXT;
	ray.direction = gl_WorldRayDirectionEXT;

	GPUInstance instance = gpuInstances[gl_InstanceCustomIndexEXT];
	int objectType = instance.type;

	vec3 cameraDir = raytracingDataConstants.cameraDir;
	// whether or not the current ray direction is the crosshair's direction
	if (abs(dot(normalize(ray.direction), normalize(cameraDir)) - 1) < 0.0000001)
	{
		isCrosshairRay = true;
	}

	isCrosshairRay = raytracingDataConstants.debugPrintCrosshairRay > 0.0 && isCrosshairRay;

	// debugPrintfEXT("istanceCustomIndexEXT: %d primitiveID: %d ObjectType: %d",
	//                gl_InstanceCustomIndexEXT,
	//                gl_PrimitiveID,
	//                objectType);

	// Tetrahedron data

	// debugPrintfEXT("gl_InstanceCustomIndexEXT: %d", gl_InstanceCustomIndexEXT);
	// debugPrintfEXT("Tetrahedron: a: %f, %f, %f",
	// tetrahedron.a.x,tetrahedron.a.y,tetrahedron.a.z); debugPrintfEXT("Tetrahedron: b: %f, %f,
	// %f", tetrahedron.b.x,tetrahedron.b.y,tetrahedron.b.z); debugPrintfEXT("Tetrahedron: c: %f,
	// %f, %f", tetrahedron.c.x,tetrahedron.c.y,tetrahedron.c.z);

	float tHit = -1;
	vec3 hitPoint = vec3(0);
	if (objectType == t_BezierTriangle2)
	{
		BezierTriangle2 bezierTriangle = bezierTriangles2[instance.bufferIndex];

		vec3 o = ray.origin;
		vec3 n1, n2;

		float dx = ray.direction.x;
		float dy = ray.direction.y;
		float dz = ray.direction.z;

		vec3 v = (abs(ray.direction.y) < 0.99) ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);
		n1 = normalize(cross(ray.direction, v));
		n2 = normalize(cross(ray.direction, n1));

		float t;
		if (raytracingDataConstants.renderSideTriangle > 0.0)
		{
			// TODO: figure out what the best guess would be
			const vec2 guesses[6] = {
			    vec2(0, 0),
			    vec2(0, 1),
			    vec2(1, 0),
			    vec2(.5, 0),
			    vec2(0, .5),
			    vec2(.5, .5),
			};

			vec2 hitCoord;
			for (int i = 0; i < 1; i++)
			{
				const vec2 guess = guesses[i];
				if (newtonsMethodTriangle2(
				        hitPoint, hitCoord, guess, o, bezierTriangle.controlPoints, n1, n2))
				{
					float dist = distance(hitPoint, o);
					if (tHit < 0 || dist < tHit)
					{
						tHit = dist;
						hitCoordinate.hitCoord = hitCoord;
					}
				}
			}

			hitCoordinate.inFrontOfSlicingPlane = false;
			if (tHit > 0 && raytracingDataConstants.enableSlicingPlanes > 0.0)
			{
				// if we still hit no object, check if we hit a slicing plane
				const int SLICING_PLANE_MAX_COUNT = 1;
				float oldTHit = tHit;

				bool debugSlicingPlanes = raytracingDataConstants.debugSlicingPlanes > 0.0;
				for (int idx = 0; idx < SLICING_PLANE_MAX_COUNT; idx++)
				{
					SlicingPlane plane = slicingPlanes[idx];

					hitCoordinate.inFrontOfSlicingPlane
					    = hitPosInFrontOfPlane(plane, hitPoint, ray);

					if (debugSlicingPlanes)
					{
					}
					else
					{
					}
				}
			}
		}
	}
	else if (objectType == t_Sphere)
	{
		// Sphere intersection
		Sphere sphere = spheres[instance.bufferIndex];
		if (isCrosshairRay)
		{
			debugPrintfEXT("sphere buffer index: %d sphere: radius: %f pos: %.2v3f color: %d ",
			               instance.bufferIndex,
			               sphere.radius,
			               sphere.center,
			               sphere.colorIdx);
		}

		tHit = hitSphere(sphere, ray);
	}
	else
	{
		// always mark as hit
		tHit = 1;
	}

	// Report hit point
	if (tHit > 0) reportIntersectionEXT(tHit, objectType);
}
